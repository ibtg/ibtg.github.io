---
layout: post
title: 'git bisect 명령어 정리'
subtitle: 'git bisect'
categories: development
tags: git
comments: true
---

- git bisect 대해서 공부하고 정리한 글입니다

---

### git bisect

- 제품에 아무런 문제가 없이 정상적으로 잘 동작했던 기능이 있는데 최근부터 조금씩 이상한 문제가 발생한 경우, 문제 상황에 맞게 개발 tool을 활용하거나 또는 개발 tool에 있는 디버깅 tool을 사용해서 소스코드를 분석 및 성능 분석을 통해 문제를 해결한다

- 하지만 디버깅 tool을 이용했음에도 불구하고 문제가 잘 파악되지 않고 이전에 작동된 기능이 최근에 잘 작동되지 않을 때 사용할 수 있는 것이 `git bisect`이다

- `git bisect`은 다음과 같은 상황에 사용할 수 있다.

- 아래처럼 커밋을 하면 커밋 히스토리가 쌓이게 되는데 3주전의 커밋까지는 괜찮았지만 3주전부터 지금까지 릴리즈가 2번 발생해서, 3주전부터 지금까지의 사이에 문제가 발생한 것 같을 때, 그 때 빠르게 문제의 커밋을 찾을 수 있게 도와주는 것이 `git bisect`이다

  ```bash

  C1 <-- C2 <-- C3 <-- C4 <-- C5 <-- C6

  ```

  - 즉, 괜찮은 시점에는 `good`, 그리고 괜찮은 시점 이전 이후 최근 시점을 `bad`라고 설정을 해놓으면 `이진탐색 알고리즘`을 이용해서 많은 커밋이 중간에 있더라도 빠르게 문제의 커밋을 찾아낼 수 있는 명령어이다.

```bash

$ git checkout "커밋 해쉬코드"
# 괜찮은 시점의 커밋으로 이동

$ git bisect start
# B라는 심볼이 생긴다

$ git bisect good
# good 이라는 마크를 해준다

$ git checkout master
# 최신 커밋으로 돌아간다

$ git bisect bad
# bad로 마크해준다

# 문제가 없는 good, 문제가 있는 bad 시점을 설정해두면 bisecting을 시작한다
# 이진탐색 알고리즘을 사용하기 때문에 사이에 12개의 커밋이 있다면 4번 정도 진행한다는 것을 보여준다

$ git log
# HEAD가 중간 지점의 어디쯤에 있는 것을 확인할 수 있다
# 이 시점에서 이슈가 발행했는지 확인한 다음에 문제가 발생하지 않았다는 것을 확인하면

$ git bisect good
# 이 부분은 good이라고 마크해준다
# 그러면 그 다음 커밋으로 이동한다
# 다시 문제가 발행하는지, 발생하지 않는지 확인한다

$ git bisect good
# 문제 없으면 다시 good이라고 마크

$ git bisect bad
# 다시 이동한 커밋에서 문제가 발생했다면 bad로 마크해준다
# 그렇다면 마지막으로 good이라고 마크한 커밋과, bad 커밋 사이로 HEAD가 이동한 것을 확인할 수 있다
# 또 다시 해당 커밋에서 문제가 발생했는지 확인한 다음 해당 커밋에서도 문제가 있었다면

$ git bisect bad
# bad로 마크

$ git bisect bad
# 그리고 이 부분에서도 이슈 있다면 bad로 마크

$ git bisect good
# 그리고 마지막 포인터가 이동한 부분에서는 이슈 없었다면 good로 마크
# 그리고 결과가 출력되고 어떠한 커밋이 문제가 있는지 알려준다

```

- 이처럼 `bisect`는 개발 tool로 디버깅하기가 힘든 경우 밖에서는 문제 없는 커밋처럼 보이지만 실제로는 버그가 포함된 커밋을 빠르게 찾아낼 수 있도록 도와주는 명령어이다

- 많은 커밋들 중 잘동작했던 커밋과 문제가 있는 커밋 두가지 지점만 잘 설정해 놓으면 `이진 탐색알고리즘`을 이용해서 빠르게 문제가 있는 커밋을 찾아낼 수 있다

- 그리고 `bisect`를 사용해서 해당하는 커밋을 찾은 경우 `bisect reset` 명령어를 이용하면 `이진 탐색`을 시작하기전 원래 브랜치로 돌아가는 것을 확인할 수 있다

```bash
$ git bisect reset

```
