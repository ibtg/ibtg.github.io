---
layout: post
title: 'Git rebase'
subtitle: 'git rebase'
categories: development
tags: git
comments: true
---

- git rebase에 대해서 공부하고 정리한 글입니다

---

### rebase

- 풀 리퀘스트를 보냈을 때 충돌이 났을 때 해결 하는 방법

1. 현재 커밋과 병합하고 싶은 커밋을 미리 내 브랜치에서 병합해서 병합 커밋을 만들고 이를 풀 리퀘스트로 보낸다

- 다음과 같이 B 원격 저장소의 1번 커밋(upstream)과 A 원본 저장소의 2번 커밋(master)을 합치려고 할 때 충돌이 나는 경우

- upstream은 원본저장소를 지칭하는 관용적 닉네임이다

 <img src="https://github.com/ibtg/ibtg.github.io/blob/master/assets/img/post_img/2020-08-06-git-rebase1.png?raw=true">

- 커밋1과 커밋2의 충돌을 해결해서 만들어진 커밋3(병합커밋)은 커밋 2와 문제 없이 병합할 수 있다

- 하지만 나의 풀 리퀘스트에 불필요한 병합커밋(3번 커밋)의 이력이 남아 있다

- 이렇게 나의 풀 리퀘스트에 불필요한 병합커밋(3번 커밋)의 이력이 남는 것을 해결하는 방법은 묵은 커밋을 방금 한 커밋처럼 이력을 조작하는 것이다

---

- 아래 그림을 보면 A는 0번 커밋으로 1번 ,2번 커밋을 만들었다

 <img src="https://github.com/ibtg/ibtg.github.io/blob/master/assets/img/post_img/2020-08-06-git-rebase2.png?raw=true">

- 0번 커밋이 옛날 커밋이여서 최신 커밋인 3번이랑 병합하려면 충돌이 일어난다.

- 그런데 1번, 2번 커밋을 0번 커밋이 아니라 3번 커밋을 베이스로 만들었다면 아무 문제 없이 Fast-forward Merge가 된다

- 이렇게 커밋의 베이스를 똑 떼서 다른 곳으로 붙여서 다시 베이스를 잡는 것을 `리베이스(rebase)`라고 한다

 <img src="https://github.com/ibtg/ibtg.github.io/blob/master/assets/img/post_img/2020-08-06-git-rebase3.png?raw=true">

- 병합 커밋이 생기는 앞의 방법과는 달리 깔끔하게 풀 리퀘스트를 보낼 수 있다 커밋 3와 커밋 2는 아무 문제 없이 병합할 수 있다.

- 간단히 정리하면 한 달 전의 코드를 기준으로 만들었던 브랜치를, 마치 최신 코드를 기준으로 만든 것 처럼 이력을 조작하는 것이다.

- 즉, rebase는 최신 커밋을 베이스로 새롭게 이력을 조작하는 것이다

- 만약 충돌이 있다면 이력을 조작하는 중간에 고쳐주면 된다

- upstream branch를 베이스로 삼고 rebase를 하면 아래와 결과를 얻게 된다

- 중간에 충돌이 일어나도 해결한 다음 소스트리 기준 `[액션 - 재배치 계속]`을 클릭해서 리베이스를 계속 진행한다

- 리베이스는 커밋을 하나씩 비교하면서 충돌이 있는지 확인하기 때문에 계속 같은 곳을 수정했다면 `[재배치 계속]`을 누를 때 마다 충돌이 여러번 날 수 있다

* 이후 푸시를 해서 로컬 저장소의 이력을 원격저장소에 반영해야 한다

* 하지만 리베이스는 이력을 조작하기 때문에 일반 푸시로는 수행할 수 없다

* 따라서 리베이스를 사용하면 `강제 푸시`를 사용해서 원격 저장소에 반영해야 한다 . 그리고 이 때 다른 개발자가 이 변경사항을 사용하고 있지 않아야 한다

* 이렇게 이력을 조작하고 푸시한느 것은 다른 개발자에게 위험한 행위기 때문에 무조건 혼자사용하는 브랜치에서만 사용해야 한다

* 리베이스는 히스토리를 강제로 조작하기 때문에 반드시 혼자만 쓰는 브랜치에서 수행해야 한다. 보통 기능 구현을 하는 브랜치는 혼자만 쓰니까 편하게 rebase 해도 된다

---

## Reference

- [팀 개발을 위한 Git, Github 시작하기](http://www.yes24.com/Product/Goods/85382769)
